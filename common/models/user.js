'use strict';
var bcrypt = require('bcryptjs');
module.exports = function(User) {

    User.customerRegister = function(credentials, include, callback) {
        console.log("here");
        var account = {
            "student_id": credentials.student_id,
            "firstname": credentials.firstname,
            "lastname": credentials.lastname,
            "password": credentials.password,
            "email": credentials.email,
            "type": "customer"
        };

        // var salt = bcrypt.genSaltSync(10);
        // var hash = bcrypt.hashSync(password, salt);
        // account.password = hash;
        // console.log(bcrypt.compareSync(credentials.password, hash)); // true

        User.findOne({
            where: {
                or: [
                    {email: account.email},
                    {student_id: account.student_id}
                ]
            }
        },function(findErr,userData){
            if(!userData){
                User.create(account,function(findErr, userData) {
                    if (findErr)
                        return callback(findErr);
                        
                    var authCredentials ={
                        email: account.email,
                        password: account.password
                    };
                    return User.login(authCredentials, include, function(loginErr, loginToken) {
                                     if (loginErr)
                                         return callback(loginErr);
                                     /* If we got to this point, the login call was successfull and we
                                      * have now access to the token generated by the login function.
                                      *
                                      * This means that now we can add extra logic and manipulate the
                                      * token before returning it. Unfortunately, the login function
                                      * does not return the user data, so if we need it we need to hit
                                      * the datasource again to retrieve it.
                                      */
                 
                                     // If needed, here we can use loginToken.userId to retrieve
                                     // the user from the datasource
                                     return User.findById(loginToken.userId, function(findErr, userData) {
                                         if (findErr)
                                             return callback(findErr);
                                        
                                             var return_data = {
                                                 user: userData.toObject(),
                                                 token: loginToken.toObject()
                                             };
                                         // Here you can do something with the user info, or the token, or both
                 
                                         // Return the access token
                                         return callback(null, return_data);
                                     });
                                 });
                });
            }else{
                callback("Account already exists");
            }

        });



        
 
 
     };
 
     /** Register a path for the new login function
      */
     User.remoteMethod('customerRegister', {
         'http': {
             'path': '/customer/register',
             'verb': 'post'
         },
         'accepts': [{
             'arg': 'credentials',
             'type': 'object',
             'description': 'Login credentials',
             'required': true,
             'http': {
                 'source': 'body'
             }
         }, {
             'arg': 'include',
             'type': 'string',
             'description': 'Related objects to include in the response. See the description of return value for more details.',
             'http': {
                 'source': 'query'
             }
         }],
         'returns': [{
             'arg': 'token',
             'type': 'object',
             'root': true
         }]
    });

    

    User.customerLogin = function(credentials, include, callback) {
        var account = {
            "email": credentials.email,
            "password": "secret",
            "displayname": data.name,
            picture: data.picture
        }
        

        // User.findOne({
        //     where: {
        //         email: account.email
        //     }
        // },function(findErr,userData){

        // });



        // // console.log("IDTOKEN: ", credentials.idToken);
 
        //  verify(credentials.idToken).then(data => {
        //      if(!data.hd || data.hd != "g.msuiit.edu.ph"){
        //          var error = new Error("Must use msuiit google suite domain");
        //          error.status = 403;
        //          return callback(error);
 
        //      }
 
        //     // console.log("Data", data);
 
        //      var account = {
        //          "email": data.email,
        //          "password": "secret",
        //          "displayname": data.name,
        //          picture: data.picture
        //      }
        //      User.findOrCreate({
        //          where: {
        //              email: account.email
        //          }
        //      }, account, function(findErr, userData) {
        //          if (findErr)
        //              return callback(findErr);
 
 
 
        //          //console.log("exists");
        //          return User.login(account, include, function(loginErr, loginToken) {
        //              if (loginErr)
        //                  return callback(loginErr);
        //              /* If we got to this point, the login call was successfull and we
        //               * have now access to the token generated by the login function.
        //               *
        //               * This means that now we can add extra logic and manipulate the
        //               * token before returning it. Unfortunately, the login function
        //               * does not return the user data, so if we need it we need to hit
        //               * the datasource again to retrieve it.
        //               */
 
        //              // If needed, here we can use loginToken.userId to retrieve
        //              // the user from the datasource
        //              return User.findById(loginToken.userId, function(findErr, userData) {
        //                  if (findErr)
        //                      return callback(findErr);
 
        //                  // Here you can do something with the user info, or the token, or both
 
        //                  // Return the access token
        //                  return callback(null, loginToken.toObject());
        //              });
        //          });
 
        //          // Here you can do something with the user info, or the token, or both
 
        //          // Return the access token
 
        //          //return callback(null, loginToken.toObject());
        //      });
 
        //      // Invoke the default login function
 
 
        //  }).catch(error => {
 
        //      return callback(error);
        //  });
 
 
 
 
     };
 
     /** Register a path for the new login function
      */
     User.remoteMethod('customerLogin', {
         'http': {
             'path': '/customer/login',
             'verb': 'post'
         },
         'accepts': [{
             'arg': 'credentials',
             'type': 'object',
             'description': 'Login credentials',
             'required': true,
             'http': {
                 'source': 'body'
             }
         }, {
             'arg': 'include',
             'type': 'string',
             'description': 'Related objects to include in the response. See the description of return value for more details.',
             'http': {
                 'source': 'query'
             }
         }],
         'returns': [{
             'arg': 'token',
             'type': 'object',
             'root': true
         }]
    });
};
